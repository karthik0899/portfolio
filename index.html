<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Block Builder 3D</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Phosphor Icons -->
    <script src="https://unpkg.com/@phosphor-icons/web"></script>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;800&display=swap');
        
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            background-color: #111827;
            user-select: none;
            -webkit-user-select: none;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            /* Critical for mobile 3D controls */
            touch-action: none;
            outline: none;
        }

        /* Glassmorphism UI Panels */
        .glass-panel {
            background: rgba(20, 20, 25, 0.85);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.3);
        }

        .no-scrollbar::-webkit-scrollbar {
            display: none;
        }
        .no-scrollbar {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }

        @keyframes popIn {
            0% { transform: scale(0.9); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }
        .animate-pop {
            animation: popIn 0.3s ease-out forwards;
        }
        
        .color-btn.active {
            transform: scale(1.15);
            border-color: white;
            box-shadow: 0 0 0 2px rgba(255,255,255,0.5);
        }
    </style>
</head>
<body>

    <!-- 3D Canvas -->
    <div id="canvas-container"></div>

    <!-- UI Overlay -->
    <div class="relative z-10 w-full h-screen pointer-events-none flex flex-col justify-between p-4 md:p-6">
        
        <!-- Top Bar -->
        <div class="flex justify-between items-start pointer-events-auto">
            <div class="glass-panel rounded-2xl p-4 animate-pop">
                <h1 class="text-white font-bold text-xl tracking-tight flex items-center gap-2">
                    <i class="ph-fill ph-cube text-blue-400"></i> Voxel<span class="text-blue-400">Builder</span>
                </h1>
                <p class="text-gray-400 text-xs mt-1 hidden md:block">Left Click: Place • Drag: Rotate • Shift+Click: Delete</p>
            </div>

            <div class="flex gap-2">
                 <button id="btn-reset-view" class="glass-panel hover:bg-white/10 text-white p-3 rounded-xl transition-all duration-200" title="Reset Camera">
                    <i class="ph ph-arrows-counter-clockwise text-xl"></i>
                </button>
                <button id="btn-clear" class="glass-panel hover:bg-red-500/20 text-white p-3 rounded-xl transition-all duration-200 group" title="Clear All">
                    <i class="ph ph-trash text-xl group-hover:text-red-400"></i>
                </button>
                <button id="btn-help" class="glass-panel hover:bg-white/10 text-white p-3 rounded-xl transition-all duration-200" title="Help">
                    <i class="ph ph-question text-xl"></i>
                </button>
            </div>
        </div>

        <!-- Bottom Bar -->
        <div class="flex flex-col md:flex-row items-end md:items-center justify-center gap-4 pointer-events-auto w-full max-w-4xl mx-auto pb-2">
            
            <!-- Mode Switcher -->
            <div class="glass-panel rounded-2xl p-2 flex gap-2 shrink-0">
                <button id="mode-build" class="flex items-center gap-2 px-4 py-2 rounded-xl bg-blue-600 text-white shadow-lg transition-all">
                    <i class="ph-bold ph-hammer"></i>
                    <span class="font-semibold text-sm">Build</span>
                </button>
                <button id="mode-delete" class="flex items-center gap-2 px-4 py-2 rounded-xl text-gray-400 hover:text-white hover:bg-white/10 transition-all">
                    <i class="ph-bold ph-eraser"></i>
                    <span class="font-semibold text-sm">Delete</span>
                </button>
            </div>

            <!-- Color Palette -->
            <div class="glass-panel rounded-2xl p-3 flex gap-3 overflow-x-auto no-scrollbar max-w-full md:max-w-lg">
                <div id="color-palette" class="flex gap-3 px-1"></div>
            </div>

            <!-- Screenshot -->
             <button id="btn-screenshot" class="glass-panel hover:bg-white/10 text-white p-3.5 rounded-xl transition-all shrink-0" title="Take Screenshot">
                <i class="ph ph-camera text-xl"></i>
            </button>
        </div>
    </div>

    <!-- Help Modal -->
    <div id="help-modal" class="fixed inset-0 z-50 bg-black/60 backdrop-blur-sm hidden flex items-center justify-center opacity-0 transition-opacity duration-300">
        <div class="glass-panel p-8 rounded-3xl max-w-md mx-4 text-center transform scale-95 transition-transform duration-300 pointer-events-auto">
            <div class="w-16 h-16 bg-blue-500/20 rounded-full flex items-center justify-center mx-auto mb-4">
                <i class="ph-duotone ph-mouse-left-click text-3xl text-blue-400"></i>
            </div>
            <h2 class="text-2xl font-bold text-white mb-2">How to Play</h2>
            <ul class="text-gray-300 text-left space-y-3 mb-6 text-sm">
                <li class="flex gap-3"><i class="ph-fill ph-cursor-click text-blue-400 mt-1"></i> <span><strong>Click</strong> to place a block.</span></li>
                <li class="flex gap-3"><i class="ph-fill ph-hand-grabbing text-blue-400 mt-1"></i> <span><strong>Drag background</strong> to rotate view.</span></li>
                <li class="flex gap-3"><i class="ph-fill ph-eraser text-red-400 mt-1"></i> <span>Use <strong>Delete Mode</strong> to remove blocks.</span></li>
                <li class="flex gap-3"><i class="ph-fill ph-arrows-out text-blue-400 mt-1"></i> <span><strong>Scroll</strong> or Pinch to zoom.</span></li>
            </ul>
            <button id="btn-close-help" class="w-full py-3 bg-blue-600 hover:bg-blue-500 text-white font-bold rounded-xl transition-colors">
                Start Building
            </button>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Configuration ---
        const COLORS = [
            0xE11D48, 0xF97316, 0xFACC15, 0x22C55E, 0x06B6D4, 
            0x3B82F6, 0x8B5CF6, 0xEC4899, 0xFFFFFF, 0x9CA3AF, 0x1F2937
        ];
        
        let selectedColor = COLORS[5];
        let isDeleteMode = false;
        let isInteractionEnabled = true;
        
        // --- Scene Setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111827);
        scene.fog = new THREE.Fog(0x111827, 200, 2000);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 20000);
        camera.position.set(500, 800, 1300);

        const renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Optimize for high DPI
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        
        const container = document.getElementById('canvas-container');
        container.appendChild(renderer.domElement);

        // --- Controls ---
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxPolarAngle = Math.PI / 2 - 0.02; // Ground collision
        controls.minDistance = 100;
        controls.maxDistance = 5000;
        controls.target.set(0,0,0);

        // --- Lights ---
        const ambientLight = new THREE.AmbientLight(0x606060, 1.5);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 2.5);
        dirLight.position.set(300, 1000, 500).normalize();
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        const d = 2000;
        dirLight.shadow.camera.left = -d;
        dirLight.shadow.camera.right = d;
        dirLight.shadow.camera.top = d;
        dirLight.shadow.camera.bottom = -d;
        scene.add(dirLight);

        // --- Environment ---
        // Massive invisible plane for raycasting everywhere
        const planeGeo = new THREE.PlaneGeometry(10000, 10000);
        planeGeo.rotateX(-Math.PI / 2);
        const planeMat = new THREE.MeshBasicMaterial({ visible: false });
        const plane = new THREE.Mesh(planeGeo, planeMat);
        scene.add(plane);

        const gridHelper = new THREE.GridHelper(2000, 40, 0x4b5563, 0x374151);
        scene.add(gridHelper);

        // Block definition
        const blockSize = 50;
        const blockGeo = new THREE.BoxGeometry(blockSize, blockSize, blockSize); 
        const getMaterial = (color) => new THREE.MeshStandardMaterial({ color: color, roughness: 0.2, metalness: 0.1 });

        // Ghost Block
        const rollOverGeo = new THREE.BoxGeometry(blockSize, blockSize, blockSize);
        const rollOverMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, opacity: 0.5, transparent: true });
        const rollOverMesh = new THREE.Mesh(rollOverGeo, rollOverMaterial);
        scene.add(rollOverMesh);

        // --- Logic ---
        const objects = [plane];
        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();

        // --- UI Setup ---
        const paletteContainer = document.getElementById('color-palette');
        COLORS.forEach((colorHex, index) => {
            const btn = document.createElement('button');
            btn.className = `color-btn w-8 h-8 md:w-10 md:h-10 rounded-full border-2 border-transparent transition-all duration-200 shrink-0`;
            btn.style.backgroundColor = '#' + colorHex.toString(16).padStart(6, '0');
            if (index === 5) btn.classList.add('active');
            
            btn.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent click from hitting canvas
                selectedColor = colorHex;
                document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                if(isDeleteMode) toggleMode('build');
            });
            paletteContainer.appendChild(btn);
        });

        const btnBuild = document.getElementById('mode-build');
        const btnDelete = document.getElementById('mode-delete');

        function toggleMode(mode) {
            isDeleteMode = (mode === 'delete');
            if (isDeleteMode) {
                btnDelete.classList.replace('text-gray-400', 'bg-red-600');
                btnDelete.classList.replace('hover:bg-white/10', 'text-white');
                btnDelete.classList.add('shadow-lg');
                
                btnBuild.classList.replace('bg-blue-600', 'text-gray-400');
                btnBuild.classList.replace('text-white', 'hover:bg-white/10');
                btnBuild.classList.remove('shadow-lg');
                
                rollOverMesh.visible = false;
                document.body.style.cursor = 'not-allowed';
            } else {
                btnBuild.classList.replace('text-gray-400', 'bg-blue-600');
                btnBuild.classList.replace('hover:bg-white/10', 'text-white');
                btnBuild.classList.add('shadow-lg');

                btnDelete.classList.replace('bg-red-600', 'text-gray-400');
                btnDelete.classList.replace('text-white', 'hover:bg-white/10');
                btnDelete.classList.remove('shadow-lg');

                rollOverMesh.visible = true;
                rollOverMaterial.color.setHex(0xff0000);
                document.body.style.cursor = 'default';
            }
        }

        btnBuild.addEventListener('click', () => toggleMode('build'));
        btnDelete.addEventListener('click', () => toggleMode('delete'));

        // --- Robust Interaction Handlers ---
        let mouseDownTime = 0;
        let isDownOnUI = false;
        const clickThreshold = 250; //ms

        function updatePointer(event) {
            // Handle both Mouse and Touch events standardly
            const x = event.clientX || (event.touches && event.touches[0]?.clientX);
            const y = event.clientY || (event.touches && event.touches[0]?.clientY);
            
            if (x !== undefined && y !== undefined) {
                pointer.set(
                    (x / window.innerWidth) * 2 - 1,
                    -(y / window.innerHeight) * 2 + 1
                );
            }
        }

        function onPointerMove(event) {
            updatePointer(event);
            raycaster.setFromCamera(pointer, camera);
            const intersects = raycaster.intersectObjects(objects, false);

            if (intersects.length > 0 && !isDeleteMode) {
                const intersect = intersects[0];
                rollOverMesh.visible = true;
                rollOverMesh.position.copy(intersect.point).add(intersect.face.normal);
                rollOverMesh.position.divideScalar(blockSize).floor().multiplyScalar(blockSize).addScalar(blockSize / 2);
                rollOverMaterial.color.setHex(selectedColor);
            } else {
                // Keep ghost hidden if not hitting anything or in delete mode
                rollOverMesh.visible = false;
            }
        }

        function onPointerDown(event) {
            // Check if interacting with UI
            if (event.target.closest('.glass-panel')) {
                isDownOnUI = true;
                return;
            }
            isDownOnUI = false;
            mouseDownTime = Date.now();
        }

        function onPointerUp(event) {
            // If we started clicking on UI, ignore the release
            if (isDownOnUI) return;
            // If we ended clicking on UI, ignore
            if (event.target.closest('.glass-panel')) return;
            // If it was a drag (rotating camera), ignore
            if (Date.now() - mouseDownTime > clickThreshold) return;

            // Process Click
            updatePointer(event);
            raycaster.setFromCamera(pointer, camera);
            const intersects = raycaster.intersectObjects(objects, false);

            if (intersects.length > 0) {
                const intersect = intersects[0];

                if (isDeleteMode || event.shiftKey) {
                    if (intersect.object !== plane) {
                        scene.remove(intersect.object);
                        objects.splice(objects.indexOf(intersect.object), 1);
                    }
                } else {
                    // Create Block
                    const voxel = new THREE.Mesh(blockGeo, getMaterial(selectedColor));
                    voxel.position.copy(intersect.point).add(intersect.face.normal);
                    voxel.position.divideScalar(blockSize).floor().multiplyScalar(blockSize).addScalar(blockSize / 2);
                    
                    voxel.castShadow = true;
                    voxel.receiveShadow = true;

                    scene.add(voxel);
                    objects.push(voxel);

                    // Animate Pop
                    voxel.scale.set(0,0,0);
                    let s = 0;
                    const animateSpawn = () => {
                        s += 0.15;
                        voxel.scale.set(s,s,s);
                        if(s < 1) requestAnimationFrame(animateSpawn);
                        else voxel.scale.set(1,1,1);
                    };
                    animateSpawn();
                }
            }
        }

        // Attach listeners to document to catch all events
        document.addEventListener('pointermove', onPointerMove);
        document.addEventListener('pointerdown', onPointerDown);
        document.addEventListener('pointerup', onPointerUp);

        // Helpers
        document.getElementById('btn-clear').addEventListener('click', () => {
            for (let i = objects.length - 1; i > 0; i--) {
                scene.remove(objects[i]);
            }
            objects.splice(1); // Keep plane
        });

        document.getElementById('btn-reset-view').addEventListener('click', () => {
            controls.reset();
            camera.position.set(500, 800, 1300);
            camera.lookAt(0, 0, 0);
        });

        document.getElementById('btn-screenshot').addEventListener('click', () => {
            renderer.render(scene, camera);
            const link = document.createElement('a');
            link.download = 'my-build.png';
            link.href = renderer.domElement.toDataURL('image/png');
            link.click();
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Modal
        const modal = document.getElementById('help-modal');
        document.getElementById('btn-help').addEventListener('click', () => {
            modal.classList.remove('hidden');
            setTimeout(() => {
                modal.classList.remove('opacity-0');
                modal.children[0].classList.remove('scale-95');
            }, 10);
        });
        document.getElementById('btn-close-help').addEventListener('click', () => {
            modal.classList.add('opacity-0');
            modal.children[0].classList.add('scale-95');
            setTimeout(() => modal.classList.add('hidden'), 300);
        });

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

    </script>
</body>
</html>
