<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Skyrise Flight Sim</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Courier New', Courier, monospace;
            user-select: none;
            -webkit-user-select: none;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
        }

        /* HUD Overlay */
        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .hud-row {
            display: flex;
            justify-content: space-between;
            padding: 20px;
        }

        .hud-text {
            color: #0ff;
            text-shadow: 0 0 10px #0ff;
            font-size: 18px;
            font-weight: bold;
            background: rgba(0, 0, 0, 0.3);
            padding: 5px 10px;
            border-radius: 4px;
            border: 1px solid rgba(0, 255, 255, 0.3);
        }

        .critical {
            color: #f00;
            text-shadow: 0 0 10px #f00;
            border-color: rgba(255, 0, 0, 0.5);
            display: none;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 40px;
            height: 40px;
            transform: translate(-50%, -50%);
            border: 2px solid rgba(0, 255, 255, 0.5);
            border-radius: 50%;
        }
        #crosshair::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 4px;
            background: #0ff;
            transform: translate(-50%, -50%);
            border-radius: 50%;
        }

        /* Game Over Screen */
        #game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
            display: none;
            pointer-events: auto;
        }

        h1 {
            color: #ff0055;
            font-size: 48px;
            margin-bottom: 10px;
            text-shadow: 0 0 20px #ff0055;
            text-transform: uppercase;
            letter-spacing: 5px;
        }

        p {
            color: #fff;
            margin-bottom: 30px;
            font-size: 18px;
        }

        button {
            background: transparent;
            color: #0ff;
            border: 2px solid #0ff;
            padding: 15px 40px;
            font-size: 20px;
            font-family: inherit;
            cursor: pointer;
            text-transform: uppercase;
            transition: all 0.3s ease;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.2);
        }

        button:hover {
            background: #0ff;
            color: #000;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.6);
        }

        /* Mobile Controls */
        #mobile-controls {
            position: absolute;
            bottom: 20px;
            left: 0;
            width: 100%;
            height: 150px;
            display: none; /* Shown via JS on touch devices */
            pointer-events: none;
        }

        .control-zone {
            position: absolute;
            bottom: 20px;
            pointer-events: auto;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.2);
            touch-action: none;
        }

        #joystick-zone {
            left: 20px;
            width: 120px;
            height: 120px;
        }

        #joystick-knob {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 50px;
            height: 50px;
            background: rgba(0, 255, 255, 0.5);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        #boost-btn {
            right: 20px;
            width: 80px;
            height: 80px;
            background: rgba(255, 100, 100, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }
        
        #boost-btn:active {
            background: rgba(255, 100, 100, 0.5);
        }

        @media (max-width: 768px) {
            .hud-text { font-size: 12px; }
            #crosshair { width: 20px; height: 20px; }
        }
    </style>
</head>
<body>

    <div id="hud">
        <div class="hud-row">
            <div class="hud-text">SPEED: <span id="speed-val">0</span> KM/H</div>
            <div class="hud-text">ALT: <span id="alt-val">0</span> FT</div>
        </div>
        <div id="crosshair"></div>
        <div class="hud-row" style="margin-top: auto;">
            <div class="hud-text critical" id="warning-msg">PULL UP!</div>
            <div class="hud-text" id="score-display">DISTANCE: 0</div>
        </div>
    </div>

    <div id="mobile-controls">
        <div id="joystick-zone" class="control-zone">
            <div id="joystick-knob"></div>
        </div>
        <div id="boost-btn" class="control-zone">BOOST</div>
    </div>

    <div id="game-over">
        <h1>CRASHED</h1>
        <p id="crash-reason">You hit a building.</p>
        <p>Total Distance: <span id="final-score">0</span></p>
        <button onclick="resetGame()">Reboot System</button>
    </div>

    <div id="canvas-container"></div>

    <script>
        // --- Constants & Config ---
        const CITY_SIZE = 4000;
        const BUILDINGS_COUNT = 600;
        const FOG_COLOR = 0x050714;
        const BASE_SPEED = 1.5;
        const MAX_SPEED = 3.5;
        const ROTATION_SPEED = 0.03;
        const BUILDING_COLORS = [0x00ffff, 0xff00ff, 0x4444ff, 0x111111, 0x222222];
        
        // --- Global State ---
        let scene, camera, renderer;
        let player, cityGroup;
        let buildings = [];
        let gameActive = true;
        let speed = BASE_SPEED;
        let distanceTraveled = 0;
        let clock = new THREE.Clock();
        
        // Inputs
        const keys = { w: false, a: false, s: false, d: false, space: false, shift: false, ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false };
        const touchInput = { x: 0, y: 0, boosting: false };

        // DOM Elements
        const elSpeed = document.getElementById('speed-val');
        const elAlt = document.getElementById('alt-val');
        const elDist = document.getElementById('score-display');
        const elWarning = document.getElementById('warning-msg');
        const elGameOver = document.getElementById('game-over');
        const elFinalScore = document.getElementById('final-score');
        const joystickZone = document.getElementById('joystick-zone');
        const joystickKnob = document.getElementById('joystick-knob');
        const boostBtn = document.getElementById('boost-btn');

        // --- Initialization ---
        function init() {
            // Scene Setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(FOG_COLOR);
            scene.fog = new THREE.FogExp2(FOG_COLOR, 0.0025);

            // Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(0, 20, 40);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffccaa, 1.5);
            dirLight.position.set(100, 300, 100);
            dirLight.castShadow = true;
            dirLight.shadow.camera.top = 500;
            dirLight.shadow.camera.bottom = -500;
            dirLight.shadow.camera.left = -500;
            dirLight.shadow.camera.right = 500;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            scene.add(dirLight);

            // City Generation
            createCity();
            createGround();

            // Player Generation
            createPlayer();

            // Listeners
            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('keydown', (e) => keys[e.key] = true);
            document.addEventListener('keyup', (e) => keys[e.key] = false);

            // Touch Controls
            setupTouchControls();

            // Start Loop
            animate();
        }

        // --- Game Objects ---

        function createPlayer() {
            player = new THREE.Group();

            // Fuselage
            const geoBody = new THREE.ConeGeometry(1, 8, 8);
            geoBody.rotateX(Math.PI / 2);
            const matBody = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, roughness: 0.4, metalness: 0.8 });
            const body = new THREE.Mesh(geoBody, matBody);
            body.castShadow = true;

            // Wings
            const geoWings = new THREE.BoxGeometry(6, 0.2, 1.5);
            const matWings = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.5 });
            const wings = new THREE.Mesh(geoWings, matWings);
            wings.position.z = 0.5;
            wings.castShadow = true;

            // Engine Glow
            const geoEngine = new THREE.CylinderGeometry(0.4, 0.1, 0.5, 8);
            geoEngine.rotateX(Math.PI / 2);
            const matEngine = new THREE.MeshBasicMaterial({ color: 0x00ffff });
            const engine = new THREE.Mesh(geoEngine, matEngine);
            engine.position.z = 4;

            player.add(body);
            player.add(wings);
            player.add(engine);

            // Cockpit Light
            const light = new THREE.PointLight(0x00ffff, 1, 20);
            light.position.set(0, 1, 0);
            player.add(light);

            scene.add(player);
            player.position.set(0, 150, 0); // Start high
        }

        function createCity() {
            cityGroup = new THREE.Group();
            const geoBox = new THREE.BoxGeometry(1, 1, 1);
            geoBox.translate(0, 0.5, 0); // Pivot at bottom

            // Create many buildings
            for (let i = 0; i < BUILDINGS_COUNT; i++) {
                const height = Math.random() * 180 + 20;
                const width = Math.random() * 20 + 10;
                
                // Emissive building materials for neon look
                const color = BUILDING_COLORS[Math.floor(Math.random() * BUILDING_COLORS.length)];
                const isNeon = Math.random() > 0.7;
                
                const material = new THREE.MeshStandardMaterial({
                    color: isNeon ? 0x111111 : 0x222222,
                    roughness: 0.2,
                    emissive: isNeon ? color : 0x000000,
                    emissiveIntensity: isNeon ? 0.8 : 0,
                });

                const mesh = new THREE.Mesh(geoBox, material);
                
                mesh.position.x = (Math.random() - 0.5) * CITY_SIZE;
                mesh.position.z = (Math.random() - 0.5) * CITY_SIZE;
                mesh.scale.set(width, height, width);
                mesh.updateMatrix();
                mesh.castShadow = true;
                mesh.receiveShadow = true;

                // Store collider data
                mesh.userData = {
                    width: width,
                    height: height,
                    x: mesh.position.x,
                    z: mesh.position.z
                };

                cityGroup.add(mesh);
                buildings.push(mesh);
            }
            scene.add(cityGroup);
        }

        function createGround() {
            const geometry = new THREE.PlaneGeometry(CITY_SIZE * 2, CITY_SIZE * 2);
            const material = new THREE.MeshStandardMaterial({ 
                color: 0x050505, 
                roughness: 0.8 
            });
            const ground = new THREE.Mesh(geometry, material);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -0.1;
            ground.receiveShadow = true;
            scene.add(ground);

            // Grid helper for futuristic floor
            const grid = new THREE.GridHelper(CITY_SIZE * 2, 100, 0x222222, 0x111111);
            scene.add(grid);
        }

        // --- Game Logic ---

        function updatePhysics() {
            if (!gameActive) return;

            const delta = clock.getDelta();

            // Inputs
            let pitchInput = 0; // Up/Down
            let rollInput = 0; // Left/Right
            let boostInput = false;

            // Keyboard
            if (keys.w || keys.ArrowUp) pitchInput = 1;
            if (keys.s || keys.ArrowDown) pitchInput = -1;
            if (keys.a || keys.ArrowLeft) rollInput = 1;
            if (keys.d || keys.ArrowRight) rollInput = -1;
            if (keys.c) boostInput = true; // Space was scrolling page, changed to C or just rely on Space with preventDefault

            // Spacebar handling (prevent scroll)
            if(keys[' ']) boostInput = true;

            // Touch
            if (touchInput.x !== 0 || touchInput.y !== 0) {
                pitchInput = -touchInput.y; // Invert Y for flight controls
                rollInput = -touchInput.x;
            }
            if (touchInput.boosting) boostInput = true;

            // Calculate Speed
            let targetSpeed = BASE_SPEED;
            if (boostInput) targetSpeed = MAX_SPEED;
            if (keys.Shift) targetSpeed = BASE_SPEED * 0.5;
            
            speed += (targetSpeed - speed) * 0.1; // Smooth acceleration

            // Apply Rotation (Pitch/Yaw/Roll mixed)
            player.rotateX(pitchInput * ROTATION_SPEED);
            player.rotateZ(rollInput * ROTATION_SPEED);
            
            // Auto-leveling slightly
            /*
            if (rollInput === 0) {
                player.rotation.z *= 0.98;
            }
            */

            // Move Forward
            player.translateY(0); // No drift
            player.translateZ(-speed);

            // Update Distance
            distanceTraveled += speed;

            // Infinite City Logic: Wrap player or buildings?
            // Easier: Wrap player position relative to center, but that messes up trail.
            // Better: Teleport buildings that are far behind to the front.
            
            const pPos = player.position;
            const spawnDist = 800;

            buildings.forEach(b => {
                // Check distance on Z relative to player rotation is hard.
                // Simple euclidean distance check for respawning
                const dist = pPos.distanceTo(b.position);
                
                // If building is too far, move it near player but random
                if (dist > 2000) {
                   // Place it somewhere in front of the player
                   // Get forward vector
                   const dir = new THREE.Vector3(0, 0, -1);
                   dir.applyQuaternion(player.quaternion);
                   dir.normalize();

                   // New Position: Player Pos + (Direction * random(1000, 2000)) + Random Offset
                   const forwardOffset = 1000 + Math.random() * 1000;
                   const sideOffset = (Math.random() - 0.5) * 1000;

                   // Simplified: Just scatter around map center if player loops? 
                   // No, let's just use a huge map and wrap player if they go too far from 0,0,0
                }
            });

            // Basic boundary wrap (Player stays within box, world loops visually)
            // Actually, for simplicity in this file size, we will just let them fly. 
            // If they fly out of the city, they are over the "Ocean".

            // Camera Follow
            // Create a desired camera position relative to player
            const relativeCameraOffset = new THREE.Vector3(0, 8, 25);
            const cameraOffset = relativeCameraOffset.applyMatrix4(player.matrixWorld);

            camera.position.lerp(cameraOffset, 0.1);
            camera.lookAt(player.position);
            
            // Update HUD
            elSpeed.innerText = Math.floor(speed * 300);
            elAlt.innerText = Math.floor(player.position.y);
            elDist.innerText = "DIST: " + Math.floor(distanceTraveled / 100);

            // Warnings
            if (player.position.y < 20) {
                elWarning.style.display = 'block';
            } else {
                elWarning.style.display = 'none';
            }

            checkCollisions();
        }

        function checkCollisions() {
            const pBox = new THREE.Box3().setFromObject(player);
            const pCenter = player.position;

            // Ground Collision
            if (pCenter.y < 1) {
                triggerGameOver("CRASHED INTO GROUND");
                return;
            }

            // Building Collision
            // Optimization: Only check buildings close by
            for (let i = 0; i < buildings.length; i++) {
                const b = buildings[i];
                const dx = Math.abs(pCenter.x - b.position.x);
                const dz = Math.abs(pCenter.z - b.position.z);
                const dy = pCenter.y;

                // Broad phase
                if (dx < 50 && dz < 50) {
                    // Narrow phase: Simple box check using userData dimensions
                    // Building Y is from 0 to scale.y
                    // Building X is center +/- scale.x/2
                    const halfW = b.userData.width / 2;
                    if (dy < b.userData.height && dx < halfW + 2 && dz < halfW + 2) {
                        triggerGameOver("HIT A BUILDING");
                        return;
                    }
                }
            }
        }

        function triggerGameOver(reason) {
            gameActive = false;
            elGameOver.style.display = 'flex';
            document.getElementById('crash-reason').innerText = reason;
            elFinalScore.innerText = Math.floor(distanceTraveled / 100) + " km";
        }

        function resetGame() {
            player.position.set(0, 150, 0);
            player.rotation.set(0, 0, 0);
            speed = BASE_SPEED;
            distanceTraveled = 0;
            gameActive = true;
            elGameOver.style.display = 'none';
            
            // Randomize city again slightly
            scene.remove(cityGroup);
            buildings = [];
            createCity();
        }

        function animate() {
            requestAnimationFrame(animate);
            updatePhysics();
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Touch Controls Setup ---
        function setupTouchControls() {
            // Detect if touch device roughly
            const isTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
            if (isTouch) {
                document.getElementById('mobile-controls').style.display = 'block';
            }

            // Joystick Logic
            let startX = 0;
            let startY = 0;
            
            joystickZone.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.changedTouches[0];
                startX = touch.clientX;
                startY = touch.clientY;
                joystickKnob.style.transition = 'none';
            });

            joystickZone.addEventListener('touchmove', (e) => {
                e.preventDefault();
                const touch = e.changedTouches[0];
                const deltaX = touch.clientX - startX;
                const deltaY = touch.clientY - startY;
                
                // Clamp visual
                const maxDist = 35;
                const dist = Math.sqrt(deltaX*deltaX + deltaY*deltaY);
                let visualX = deltaX;
                let visualY = deltaY;
                
                if (dist > maxDist) {
                    visualX = (deltaX / dist) * maxDist;
                    visualY = (deltaY / dist) * maxDist;
                }

                joystickKnob.style.transform = `translate(calc(-50% + ${visualX}px), calc(-50% + ${visualY}px))`;

                // Normalize output -1 to 1
                touchInput.x = Math.max(-1, Math.min(1, deltaX / maxDist));
                touchInput.y = Math.max(-1, Math.min(1, deltaY / maxDist));
            });

            joystickZone.addEventListener('touchend', (e) => {
                e.preventDefault();
                touchInput.x = 0;
                touchInput.y = 0;
                joystickKnob.style.transition = 'transform 0.2s';
                joystickKnob.style.transform = `translate(-50%, -50%)`;
            });

            // Boost Button
            boostBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                touchInput.boosting = true;
                boostBtn.style.background = "rgba(255, 100, 100, 0.5)";
            });
            
            boostBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                touchInput.boosting = false;
                boostBtn.style.background = "rgba(255, 100, 100, 0.2)";
            });
        }

        // Boot
        init();

    </script>
</body>
</html>
