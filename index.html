<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Skyrise Flight Sim v2.0</title>
    <!-- Core Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Post-processing scripts -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>

    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Courier New', Courier, monospace;
            user-select: none;
            -webkit-user-select: none;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
            background: #020205; /* Darker background for loading */
        }

        /* HUD Overlay */
        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .hud-row {
            display: flex;
            justify-content: space-between;
            padding: 20px;
        }

        .hud-text {
            color: #0ff;
            text-shadow: 0 0 10px #0ff;
            font-size: 18px;
            font-weight: bold;
            background: rgba(0, 0, 0, 0.3);
            padding: 5px 10px;
            border-radius: 4px;
            border: 1px solid rgba(0, 255, 255, 0.3);
        }

        .critical {
            color: #f00;
            text-shadow: 0 0 10px #f00;
            border-color: rgba(255, 0, 0, 0.5);
            display: none;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 40px;
            height: 40px;
            transform: translate(-50%, -50%);
            border: 2px solid rgba(0, 255, 255, 0.5);
            border-radius: 50%;
        }
        #crosshair::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 4px;
            background: #0ff;
            transform: translate(-50%, -50%);
            border-radius: 50%;
        }

        /* Game Over Screen */
        #game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
            display: none;
            pointer-events: auto;
        }

        h1 {
            color: #ff0055;
            font-size: 48px;
            margin-bottom: 10px;
            text-shadow: 0 0 20px #ff0055;
            text-transform: uppercase;
            letter-spacing: 5px;
        }

        p {
            color: #fff;
            margin-bottom: 30px;
            font-size: 18px;
        }

        button {
            background: transparent;
            color: #0ff;
            border: 2px solid #0ff;
            padding: 15px 40px;
            font-size: 20px;
            font-family: inherit;
            cursor: pointer;
            text-transform: uppercase;
            transition: all 0.3s ease;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.2);
        }

        button:hover {
            background: #0ff;
            color: #000;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.6);
        }

        /* Mobile Controls */
        #mobile-controls {
            position: absolute;
            bottom: 20px;
            left: 0;
            width: 100%;
            height: 150px;
            display: none; /* Shown via JS on touch devices */
            pointer-events: none;
        }

        .control-zone {
            position: absolute;
            bottom: 20px;
            pointer-events: auto;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.2);
            touch-action: none;
        }

        #joystick-zone {
            left: 20px;
            width: 120px;
            height: 120px;
        }

        #joystick-knob {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 50px;
            height: 50px;
            background: rgba(0, 255, 255, 0.5);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        #boost-btn {
            right: 20px;
            width: 80px;
            height: 80px;
            background: rgba(255, 100, 100, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }
        
        #boost-btn:active {
            background: rgba(255, 100, 100, 0.5);
        }

        @media (max-width: 768px) {
            .hud-text { font-size: 12px; }
            #crosshair { width: 20px; height: 20px; }
        }
    </style>
</head>
<body>

    <div id="hud">
        <div class="hud-row">
            <div class="hud-text">SPEED: <span id="speed-val">0</span> KM/H</div>
            <div class="hud-text">ALT: <span id="alt-val">0</span> FT</div>
        </div>
        <div id="crosshair"></div>
        <div class="hud-row" style="margin-top: auto;">
            <div class="hud-text critical" id="warning-msg">PULL UP!</div>
            <div class="hud-text" id="score-display">DISTANCE: 0</div>
        </div>
    </div>

    <div id="mobile-controls">
        <div id="joystick-zone" class="control-zone">
            <div id="joystick-knob"></div>
        </div>
        <div id="boost-btn" class="control-zone">BOOST</div>
    </div>

    <div id="game-over">
        <h1>CRASHED</h1>
        <p id="crash-reason">You hit a building.</p>
        <p>Total Distance: <span id="final-score">0</span></p>
        <button onclick="resetGame()">Reboot System</button>
    </div>

    <div id="canvas-container"></div>

    <script>
        // --- Constants & Config ---
        const CITY_SIZE = 4000;
        const BUILDINGS_COUNT = 800; // Increased for denser city
        const FOG_COLOR = 0x020205; // Darker, more atmospheric fog
        const BASE_SPEED = 1.5;
        const MAX_SPEED = 4.0; // Slightly faster max speed
        const ROTATION_SPEED = 0.025; // Slightly smoother rotation
        const BUILDING_COLORS = [0x00ffff, 0xff00ff, 0x4444ff, 0xff3300, 0x00ff00];
        
        // --- Global State ---
        let scene, camera, renderer, composer;
        let player, cityGroup, particleSystem;
        let buildings = [];
        let gameActive = true;
        let speed = BASE_SPEED;
        let distanceTraveled = 0;
        let clock = new THREE.Clock();
        
        let buildingTexture, groundTexture;

        // Inputs
        const keys = { w: false, a: false, s: false, d: false, space: false, shift: false, ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false };
        const touchInput = { x: 0, y: 0, boosting: false };

        // DOM Elements
        const elSpeed = document.getElementById('speed-val');
        const elAlt = document.getElementById('alt-val');
        const elDist = document.getElementById('score-display');
        const elWarning = document.getElementById('warning-msg');
        const elGameOver = document.getElementById('game-over');
        const elFinalScore = document.getElementById('final-score');
        const joystickZone = document.getElementById('joystick-zone');
        const joystickKnob = document.getElementById('joystick-knob');
        const boostBtn = document.getElementById('boost-btn');

        // --- Texture Generation Functions ---
        
        function createBuildingTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 128;
            const context = canvas.getContext('2d');

            // Base color
            context.fillStyle = '#111';
            context.fillRect(0, 0, canvas.width, canvas.height);

            // Windows
            context.fillStyle = '#444'; // Dark windows by default
            for (let y = 0; y < canvas.height; y += 8) {
                for (let x = 0; x < canvas.width; x += 8) {
                    if (Math.random() > 0.2) { // Randomly lit
                        context.fillRect(x + 1, y + 1, 6, 6);
                    }
                }
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(1, 4); // Repeat more vertically
            return texture;
        }

        function createGroundTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const context = canvas.getContext('2d');

            // Simple noise for asphalt/concrete
            const imageData = context.createImageData(canvas.width, canvas.height);
            for (let i = 0; i < imageData.data.length; i += 4) {
                const val = Math.floor(Math.random() * 40 + 20); // Dark gray noise
                imageData.data[i] = val;
                imageData.data[i+1] = val;
                imageData.data[i+2] = val;
                imageData.data[i+3] = 255;
            }
            context.putImageData(imageData, 0, 0);

            // Add some faint grid lines
            context.strokeStyle = 'rgba(50, 50, 70, 0.2)';
            context.lineWidth = 2;
            context.beginPath();
            for(let i=0; i<canvas.width; i+=32) {
                context.moveTo(i, 0); context.lineTo(i, canvas.height);
                context.moveTo(0, i); context.lineTo(canvas.width, i);
            }
            context.stroke();

            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(50, 50); // Heavy repetition for a large ground
            return texture;
        }


        // --- Initialization ---
        function init() {
            // Generate Textures
            buildingTexture = createBuildingTexture();
            groundTexture = createGroundTexture();

            // Scene Setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(FOG_COLOR);
            scene.fog = new THREE.FogExp2(FOG_COLOR, 0.002); // Decreased density for more view distance

            // Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 3000); // Increased far plane
            camera.position.set(0, 20, 40);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance", stencil: false, depth: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); // Cap pixel ratio for performance with post-proc
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Softer shadows
            renderer.outputEncoding = THREE.sRGBEncoding; // Better color handling
            renderer.toneMapping = THREE.ACESFilmicToneMapping; // Cinematic tone mapping
            renderer.toneMappingExposure = 1.2;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Post-Processing Setup
            setupPostProcessing();

            // Lights
            setupLights();

            // Game World
            createCity();
            createGround();
            createAtmosphericParticles();
            createPlayer();

            // Listeners
            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('keydown', (e) => keys[e.key] = true);
            document.addEventListener('keyup', (e) => keys[e.key] = false);

            // Touch Controls
            setupTouchControls();

            // Start Loop
            animate();
        }

        function setupLights() {
            const ambientLight = new THREE.HemisphereLight(0xddeeff, 0x0f0e0d, 0.2); // Sky/Ground color mix
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffaa88, 1.5); // More orange/sunset-like
            dirLight.position.set(-100, 300, 200); // Changed position
            dirLight.castShadow = true;
            dirLight.shadow.camera.top = 1000;
            dirLight.shadow.camera.bottom = -1000;
            dirLight.shadow.camera.left = -1000;
            dirLight.shadow.camera.right = 1000;
            dirLight.shadow.camera.near = 0.1;
            dirLight.shadow.camera.far = 2000;
            dirLight.shadow.bias = -0.0005; // Reduces shadow acne
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            scene.add(dirLight);
        }

        function setupPostProcessing() {
            composer = new THREE.EffectComposer(renderer);
            const renderPass = new THREE.RenderPass(scene, camera);
            composer.addPass(renderPass);

            // Bloom for neon effect
            const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.2;
            bloomPass.strength = 1.2; // Intensity of glow
            bloomPass.radius = 0.5; // Spread of glow
            composer.addPass(bloomPass);
        }

        // --- Game Objects ---

        function createPlayer() {
            player = new THREE.Group();

            // Fuselage
            const geoBody = new THREE.ConeGeometry(1, 8, 16); // Smoother geometry
            geoBody.rotateX(Math.PI / 2);
            const matBody = new THREE.MeshStandardMaterial({ 
                color: 0x333344, 
                roughness: 0.3, 
                metalness: 0.9,
                envMapIntensity: 1.0
            });
            const body = new THREE.Mesh(geoBody, matBody);
            body.castShadow = true;

            // Wings
            const geoWings = new THREE.BoxGeometry(6, 0.2, 1.5);
            const matWings = new THREE.MeshStandardMaterial({ color: 0x222233, roughness: 0.5, metalness: 0.6 });
            const wings = new THREE.Mesh(geoWings, matWings);
            wings.position.z = 0.5;
            wings.castShadow = true;

            // Engine Glow
            const geoEngine = new THREE.CylinderGeometry(0.4, 0.1, 0.5, 16);
            geoEngine.rotateX(Math.PI / 2);
            const matEngine = new THREE.MeshBasicMaterial({ color: 0x00ffff });
            const engine = new THREE.Mesh(geoEngine, matEngine);
            engine.position.z = 4;

            // Add a point light for the engine to cast light on the ship and environment
            const engineLight = new THREE.PointLight(0x00ffff, 2, 15);
            engineLight.position.set(0, 0, 4.2);
            player.add(engineLight);

            player.add(body);
            player.add(wings);
            player.add(engine);

            // Cockpit Light
            const cockpitLight = new THREE.PointLight(0x00ffff, 0.5, 5);
            cockpitLight.position.set(0, 1, -1);
            player.add(cockpitLight);

            scene.add(player);
            player.position.set(0, 150, 0); // Start high
        }

        function createCity() {
            cityGroup = new THREE.Group();
            const geoBox = new THREE.BoxGeometry(1, 1, 1);
            geoBox.translate(0, 0.5, 0); // Pivot at bottom

            // Create many buildings
            for (let i = 0; i < BUILDINGS_COUNT; i++) {
                const height = Math.random() * 250 + 30; // Taller buildings
                const width = Math.random() * 25 + 10;
                
                const color = BUILDING_COLORS[Math.floor(Math.random() * BUILDING_COLORS.length)];
                const isNeon = Math.random() > 0.6; // More neon buildings
                
                const material = new THREE.MeshStandardMaterial({
                    color: isNeon ? 0x050505 : 0x111111,
                    roughness: 0.1,
                    metalness: 0.8,
                    map: buildingTexture, // Add texture
                    emissive: isNeon ? color : 0x000000,
                    emissiveMap: isNeon ? buildingTexture : null, // Use texture for emissive pattern
                    emissiveIntensity: isNeon ? 1.5 : 0, // Brighter neon
                });
                
                // Adjust texture repeat based on building size
                material.map.repeat.set(1, height / 32);
                if (material.emissiveMap) {
                    material.emissiveMap.repeat.set(1, height / 32);
                }

                const mesh = new THREE.Mesh(geoBox, material);
                
                mesh.position.x = (Math.random() - 0.5) * CITY_SIZE * 1.2; // Spread out more
                mesh.position.z = (Math.random() - 0.5) * CITY_SIZE * 1.2;
                mesh.scale.set(width, height, width);
                mesh.updateMatrix();
                mesh.castShadow = true;
                mesh.receiveShadow = true;

                // Store collider data
                mesh.userData = {
                    width: width,
                    height: height,
                    x: mesh.position.x,
                    z: mesh.position.z
                };

                cityGroup.add(mesh);
                buildings.push(mesh);
            }
            scene.add(cityGroup);
        }

        function createGround() {
            const geometry = new THREE.PlaneGeometry(CITY_SIZE * 3, CITY_SIZE * 3); // Larger ground
            const material = new THREE.MeshStandardMaterial({ 
                color: 0x111111, 
                roughness: 0.9,
                metalness: 0.3,
                map: groundTexture, // Use generated noise texture
                bumpMap: groundTexture, // Use same texture for bump for some depth
                bumpScale: 0.5
            });
            const ground = new THREE.Mesh(geometry, material);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -0.1;
            ground.receiveShadow = true;
            scene.add(ground);

            // Grid helper for futuristic floor - make it subtler
            const grid = new THREE.GridHelper(CITY_SIZE * 3, 150, 0x333333, 0x111122);
            grid.position.y = 0.05; // Slightly above ground to avoid z-fighting
            scene.add(grid);
        }

        function createAtmosphericParticles() {
            const particleCount = 2000;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);

            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = (Math.random() - 0.5) * CITY_SIZE * 1.5;
                positions[i * 3 + 1] = Math.random() * 300;
                positions[i * 3 + 2] = (Math.random() - 0.5) * CITY_SIZE * 1.5;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

            const material = new THREE.PointsMaterial({
                color: 0x5577aa,
                size: 1.5,
                transparent: true,
                opacity: 0.4,
                fog: true,
                blending: THREE.AdditiveBlending
            });

            particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);
        }

        // --- Game Logic ---

        function updatePhysics() {
            if (!gameActive) return;

            const delta = clock.getDelta();

            // Inputs
            let pitchInput = 0; // Up/Down
            let rollInput = 0; // Left/Right
            let boostInput = false;

            // Keyboard
            if (keys.w || keys.ArrowUp) pitchInput = 1;
            if (keys.s || keys.ArrowDown) pitchInput = -1;
            if (keys.a || keys.ArrowLeft) rollInput = 1;
            if (keys.d || keys.ArrowRight) rollInput = -1;
            if (keys.c) boostInput = true;

            // Spacebar handling (prevent scroll)
            if(keys[' ']) boostInput = true;

            // Touch
            if (touchInput.x !== 0 || touchInput.y !== 0) {
                pitchInput = -touchInput.y; // Invert Y for flight controls
                rollInput = -touchInput.x;
            }
            if (touchInput.boosting) boostInput = true;

            // Calculate Speed
            let targetSpeed = BASE_SPEED;
            if (boostInput) targetSpeed = MAX_SPEED;
            if (keys.Shift) targetSpeed = BASE_SPEED * 0.5;
            
            speed += (targetSpeed - speed) * 0.05; // Smoother acceleration

            // Apply Rotation (Pitch/Yaw/Roll mixed)
            const rotSpeed = ROTATION_SPEED * (speed / BASE_SPEED); // Turn faster when moving faster
            player.rotateX(pitchInput * rotSpeed);
            player.rotateZ(rollInput * rotSpeed);
            
            // Move Forward
            player.translateY(0); // No drift
            player.translateZ(-speed);

            // Update Distance
            distanceTraveled += speed;
            
            // Update Particles (wrap around player for infinite feeling)
            const positions = particleSystem.geometry.attributes.position.array;
            for (let i = 0; i < positions.length; i += 3) {
                // Move particles slowly downwards and backwards relative to world
                positions[i+1] -= delta * 5; 
                // positions[i+2] += delta * speed * 50; // Move past player

                // Wrap around relative to player position
                if (positions[i+1] < 0) positions[i+1] = 300;
                
                const pX = positions[i];
                const pZ = positions[i+2];
                const dx = pX - player.position.x;
                const dz = pZ - player.position.z;

                if (Math.abs(dx) > CITY_SIZE / 1.5) positions[i] -= Math.sign(dx) * CITY_SIZE * 1.5;
                if (Math.abs(dz) > CITY_SIZE / 1.5) positions[i+2] -= Math.sign(dz) * CITY_SIZE * 1.5;
            }
            particleSystem.geometry.attributes.position.needsUpdate = true;


            // Camera Follow
            // Create a desired camera position relative to player
            const relativeCameraOffset = new THREE.Vector3(0, 8, 25);
            // Add slight camera shake based on speed
            const shake = (speed - BASE_SPEED) / (MAX_SPEED - BASE_SPEED) * 0.2;
            if (shake > 0) {
                relativeCameraOffset.x += (Math.random() - 0.5) * shake;
                relativeCameraOffset.y += (Math.random() - 0.5) * shake;
            }

            const cameraOffset = relativeCameraOffset.applyMatrix4(player.matrixWorld);

            camera.position.lerp(cameraOffset, 0.1);
            camera.lookAt(player.position.x, player.position.y + 2, player.position.z); // Look slightly above player
            
            // Update HUD
            elSpeed.innerText = Math.floor(speed * 300);
            elAlt.innerText = Math.floor(player.position.y);
            elDist.innerText = "DIST: " + Math.floor(distanceTraveled / 100);

            // Warnings
            if (player.position.y < 30) {
                elWarning.style.display = 'block';
            } else {
                elWarning.style.display = 'none';
            }

            checkCollisions();
        }

        function checkCollisions() {
            const pBox = new THREE.Box3().setFromObject(player);
            const pCenter = player.position;

            // Ground Collision
            if (pCenter.y < 2) {
                triggerGameOver("CRASHED INTO GROUND");
                return;
            }

            // Building Collision
            // Optimization: Only check buildings close by
            for (let i = 0; i < buildings.length; i++) {
                const b = buildings[i];
                const dx = Math.abs(pCenter.x - b.position.x);
                const dz = Math.abs(pCenter.z - b.position.z);
                const dy = pCenter.y;

                // Broad phase
                if (dx < 80 && dz < 80) {
                    // Narrow phase: Simple box check using userData dimensions
                    // Building Y is from 0 to scale.y
                    // Building X is center +/- scale.x/2
                    const halfW = b.userData.width / 2;
                    if (dy < b.userData.height && dx < halfW + 3 && dz < halfW + 3) {
                        triggerGameOver("HIT A BUILDING");
                        return;
                    }
                }
            }
        }

        function triggerGameOver(reason) {
            gameActive = false;
            elGameOver.style.display = 'flex';
            document.getElementById('crash-reason').innerText = reason;
            elFinalScore.innerText = Math.floor(distanceTraveled / 100) + " km";
        }

        function resetGame() {
            player.position.set(0, 150, 0);
            player.rotation.set(0, 0, 0);
            speed = BASE_SPEED;
            distanceTraveled = 0;
            gameActive = true;
            elGameOver.style.display = 'none';
            
            // Randomize city again slightly
            scene.remove(cityGroup);
            buildings = [];
            createCity();
        }

        function animate() {
            requestAnimationFrame(animate);
            updatePhysics();
            // renderer.render(scene, camera); // Replaced by composer
            composer.render();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight); // Update composer size
        }

        // --- Touch Controls Setup ---
        function setupTouchControls() {
            // Detect if touch device roughly
            const isTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
            if (isTouch) {
                document.getElementById('mobile-controls').style.display = 'block';
            }

            // Joystick Logic
            let startX = 0;
            let startY = 0;
            
            joystickZone.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.changedTouches[0];
                startX = touch.clientX;
                startY = touch.clientY;
                joystickKnob.style.transition = 'none';
            });

            joystickZone.addEventListener('touchmove', (e) => {
                e.preventDefault();
                const touch = e.changedTouches[0];
                const deltaX = touch.clientX - startX;
                const deltaY = touch.clientY - startY;
                
                // Clamp visual
                const maxDist = 35;
                const dist = Math.sqrt(deltaX*deltaX + deltaY*deltaY);
                let visualX = deltaX;
                let visualY = deltaY;
                
                if (dist > maxDist) {
                    visualX = (deltaX / dist) * maxDist;
                    visualY = (deltaY / dist) * maxDist;
                }

                joystickKnob.style.transform = `translate(calc(-50% + ${visualX}px), calc(-50% + ${visualY}px))`;

                // Normalize output -1 to 1
                touchInput.x = Math.max(-1, Math.min(1, deltaX / maxDist));
                touchInput.y = Math.max(-1, Math.min(1, deltaY / maxDist));
            });

            joystickZone.addEventListener('touchend', (e) => {
                e.preventDefault();
                touchInput.x = 0;
                touchInput.y = 0;
                joystickKnob.style.transition = 'transform 0.2s';
                joystickKnob.style.transform = `translate(-50%, -50%)`;
            });

            // Boost Button
            boostBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                touchInput.boosting = true;
                boostBtn.style.background = "rgba(255, 100, 100, 0.5)";
            });
            
            boostBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                touchInput.boosting = false;
                boostBtn.style.background = "rgba(255, 100, 100, 0.2)";
            });
        }

        // Boot
        init();

    </script>
</body>
</html>
